URL Роутинг
===========

........... для чего вообще нужен роутинг?

Модуль URL Роутинг решает две задачи:
    
  *  Преобразование URL в вызов конкретной функции-обработчика
  *  Генерация URL для конкретной функции-обработчика 

Преобразование URL в вызов конкретной функции-обработчика
---------------------------------------------------------
Основное назначение роутинга - связать набранный пользователем URL с
функцией-обработчиком на сервере.

Весь процесс происходит следующим образом:
    
  1.  Пользователь набирает URL в браузере
  2.  URL запрос передается браузером на веб сервер  
  3.  Веб сервер передает запрос Пони  
  4.  Модуль URL роутинг анализирует запрос, находит соответствующий обработчик,
выделяет параметры из URL запроса и производит вызов функции-обработчика с этими параметрами

Динамический веб сайт это набор функций-обработчиков, которые вызываются в ответ
на набранные пользователем URL

### Связывание URL с функцией-обработчиком ###
Давайте рассмотрим как связать URL с функцией-обработчиком. Вот пример законченной программы,
которая генерирует страницу с помощью Пони.


    from pony.main import *     (1)

    @http                       (2)
    def mypage():               (3)
        return "Hello world!"   (4) 

    http.start()                (5) 

(1) В первой строчке мы импортируем все самое необходимое для Пони. После того как выполнен
import мы можем использовать компоненты Пони в нашем коде.  
(2) Здесь мы _декорируем_ функцию mypage с помощью декоратора http.  
Тем самым мы даем понять Пони, что мы хотим, чтобы эта функция была обработчиком для URL и
была бы доступна для пользователей веб сайта.  
(3) Объявление функции mypage.  
(4) Возвращаемое значение будет простая строка "Hello world!".  
(5) Запускаем веб сервер.  
Как и все примеры, мы можем запустить этот пример из интерактивного режима и
посмотреть что получилось.  

После того как мы запустили приведенный выше код в интерактивном режиме или в виде отдельного файла,
мы можем посмотреть на сгенерированую страницу в браузере. Давайте разберемся, какой URL нужно
набрать, чтобы увидеть результат.
Когда мы указываем декоратор http без параметров, Пони по умолчанию берет параметры 
из самой функции. В этом примере соответствующий этой функции URL будет '/mypage'.
Командой `http.start()` мы запустили веб сервер, который по умолчанию обслуживает порт 8080.
Теперь наберем в браузере http://localhost:8080/mypage и увидим наше приветствие.

    Картинка

Как вы видете из примера, связать URL с функцией-обработчиком в Пони очень просто.

### Передача параметров в функцию ###
На практике часто возникает необходимость передать параметры в функцию-обработчик.
В следующем примере мы рассмотрим как это делается в Пони.

    from pony.main import *                                   (1)

    @http                                                     (2)
    def mypage2(param1, param2):                              (3)
        return "Hello again, param1=%s param2=%s!" % (param1, param2)   (4)

    http.start()                                              (5)

В этом примере, котрый содержит в себе все необходимое для работоспособного приложения,
выполняются следующие действия:
  (1) Импортируем компоненты Пони.  
  (2) Указываем Пони, что далее идет функция-обработчик URL.  
  (3) Объявлем функцию mypage2 с двумя параметрами - param1 и param2.  
  (4) Покажем пользователю приветствие и полученные параметры.  
  (5) Запускаем веб сервер.  

URL для этой страницы будет немного отличаться от предыдущего.
У функции mypage два обязательных параметра и раз эти параметры обязательные они должны присутствовать в URL.
Допустим мы хотим передать функции следующие значения: param1=value1, param2=value2
Пони ожидает, что эти параметры будут указаны в URL стандартным способом:

    http://localhost:8080/mypage2?param1=value1&param2=value2

Если мы наберем этот URL в браузере, то увидим страницу, сгенерированную Пони:

    Картинка    

### Значения по умолчанию ###
Что если мы хотим, чтобы параметры в функции имели значения по умолчанию?
Следующий пример очень похож на предыдущий, с одним отличием -
мы зададим нашим переменным параметры по умолчанию:

    from pony.main import *                         

    @http                                           
    def mypage3(param1='default1', param2='default2'):                 (1)
        return "Hello again, param1=%s param2=%s!" % (param1, param2)   

    http.start()                                    

(1) Объявляем функцию mypage3 и задаем ей параметры по умолчанию param1='default1', param2='default2'

Теперь, если мы не будем указывать ни одного параметра в URL, мы увидим, что Пони подставит
значения заданные по умолчанию:

    Картинка для http://localhost:8080/mypage3

Мы также можем указать значение только для одного из параметров:    

    Картинка для http://localhost:8080/mypage3?param1=value1

    Картинка для http://localhost:8080/mypage3?param2=value2

Или указать значения для обоих параметров:

    Картинка для http://localhost:8080/mypage3?param1=value1&param2=value2    


Генерация URL для конкретной функции-обработчика 
------------------------------------------------
В предыдущем разделе мы познакомились с тем, как отображать URL на функцию-обработчик.
Часто при построении динамического веб сайта возникает необходимость отобразить
URL, который соответствует определенной функции-обработчику. Например, чтобы добавить сслыку
на раздел нашего сайта в главное меню. Конечно, зная какой URL соответствует фунции на данный момент,
можно просто вписать ее в HTML код. Но в этом случае каждое изменение URL потребует обновления
ранее указанной ссылки вручную.
Для генерации URL в Пони используется функция url, которой передается
функция-обработчик и ее параметры.

url(func, arguments)

Для примера попробуем отобразить URL для функций mypage и mypage2 из предыдущего раздела

    >>> url(mypage)
    '/mypage'
    >>> url(mypage2, param1='value1', param2='value2')
    '/mypage2?param1=value1&param2=value2'

Как видно из примера, названия параметров должны соответствовать параметрам, определенным
при объявлении функции.

Наличие удобного и гибкого роутинга позволяет менять структуру адресов веб сайта
не изменяя при этом сами функции, которые генерируют страницы. 

Продвинутный роутинг
====================
Рассмотренных ранее возожностей вполне достаточно, чтобы построить веб сайт с помощью Пони.
В этом разделе мы рассмотрим возможности Пони, которые дают неограниченную свободу разработчику
оставаясь при этом максимально простыми для освоения, как и все компоненты Пони.

### Любые URL для функции-обработчика ###
До текущего момента мы не указывали никаких параметров для декоратора @http.
В таком режиме URL, по которому доступна функция строится по умолчанию

    @http
    def archive(year, month):
        ...

Для этого кода URL, по которому будет доступна эта функция будет /archive?year=value1&month=value2
Перед вами может стоять задача, когда URL должен соответствовать какой то
структуре, а параметры нужно передавать не поименно, а брать из самого URL.
Например для архива нашего сайта мы хотим, чтобы все статьи за Ноябрь 2008 года были бы доступны
по таком адресу:

    /archive/2008/11/posts

Решить такого рода задачу с помощью Пони очень просто. Для этогон нам нужно указать Пони,
какая часть URL будет являться параметром:

    @http('/archive/$year/$month/posts')
    def archive(year, month):
        ...    

Каждый идентификатор, который начинается со знака '$' представляет собой динамическую часть URL.
Когда Пони сопоставляет URL с конкретной функцией-обработчиком, она выделяет динамические части из URL и
передает в функцию как параметры.

Разделителем между параметрами может быть не только символ '/'. Такие варианты тоже возможны:

    >>> @http('/archive/$year-$month/posts')
    ... def archive2(year=None, month=None):
    ... 	pass
    ... 
    >>> @http('/archive/$year.$month/posts')
    ... def archive3(year=None, month=None):
    ... 	pass
    ... 
    >>> url(archive2, 2008, 11)
    '/archive/2008-11/posts'
    >>> url(archive3, 2008, 11)
    '/archive/2008.11/posts'
    >>>     


### Несколько URL для одного обработчика ###
Ничто не остается постоянным и в какой то момент вам может понадобиться изменить структуру адресов веб сайта.
Используя возможности Пони это можно сделать довольно быстро, но нам нужно помнить, что некоторые пользователи
могли сделать закладки используя старые адреса. Если поменять URL страниц, они не смогут открыть их любимую страницу.
С точки зрения поисковой машины смена адресов тоже будет не очень комфортной.
Поисковая машина хранит индексы старых URL и пройдет какое то время
пока она перестроит индекс.
А все это время пользователи сайта будут испытывать неудобства.

Используя роутинг в Пони можно очень легко изменять структуру веб сайта,
не нарушая при этом работы тех пользователей, которые привыкли работать со старой структурой.
Любой фунции-обработчику можно присвоить сколько угодно URL адресов:

    >>> @http('/old-structure/archive/$year-$month/posts')
    ... @http('/new-structure/posts-archive/$year/$month/posts')    
    ... def archive2(year=None, month=None):
    ... 	pass
    ...     

В этом примере пользователь получит ту же самую страницу открыв ее по двум разным URL. 

### Редирект ###
Использование нескольких URL для одной и той же страницы решает задачу введения новой структуры адресов.
Но вместе с удобством появляется неоднозначность. Пользователи не могут определить по внешнему виду какой адрес
старый, а какой новый. 
Поисковые машины присваивают бОльший рейтинг страницам с бОльшим числом линков на них. Если у одной и той же страницы
несколько адресов, то разные люди будут делать ссылки на разные адреса и это понизит эффективность веб сайта.

Хорошей практикой считается иметь один постоянный URL для страницы. Если по какой то причине нужно
сопоставить странице альтернативный URL, нужно обеспечить редирект с альтернативных адресов на
постоянный URL. Редирект - это автоматическая переадресация браузера на другой URL.
Для того, чтобы обеспечить редирект на новый адрес нужно указать `redirect=True` в декораторе со старым URL.
Для предыдущего примера это будет выглядеть так:

    >>> @http('/old-structure/archive/$year-$month/posts', redirect=True)
    ... @http('/new-structure/posts-archive/$year/$month/posts')    
    ... def archive2(year=None, month=None):
    ... 	pass
    ...      

Редирект может быть нескольких типов, самые часто используемые из которых - постоянный и временный.
По умолчанию, если указать параметр `redirect=True`, Пони делает постоянный редирект
с кодом '301 Moved Permanently'.
Если поисковая машина натыкается на постоянный редирект, то отныне она будет обращаться сразу по новому адресу.
Временный редирект обозначается кодом '307 Temporary Redirect'
Если редирект временный, то поисковая машина не должна заменять старый адрес на новый.
Чтобы сделать временный редирект, или редирект какого то другого типа, нужно указать код редиректа
в качестве параметра:

    @http('/old-structure/archive/$year-$month/posts', redirect='307')

Другие возможные значения параметра кувшкусе 

Редирект в Пони используется также и для отображения результата отсылки формы, для того чтобы обновление
страницы не приводило к повторной отсылке формы на сервер. _см ссылку_ нужно ли здесь про формы?

### Символ '/' в конце URL ###
Случается ситуация, когда URL, который написан в декораторе отличается от того, который набран в
браузере только наличием или отсутствием знака '/' на конце.

Когда Пони анализирует URL полученный от браузера она сначала попытается найти точное соответствие.
Если точное соответствие есть - вызывается соответствующий обработчик.
Если точное совпадение не найдено, Пони попробует убрать/подставить слэш в конце URL и найти
обработчик для такого URL. Если при этом найдено соответствие, Пони автоматически выполняет редирект
по найденному адресу со статусом '301 Moved Permanently'

### Параметры декоратора http ### 
Декоратор http принимает несколько параметров:

`url`

`host`

`port`

`redirect`  
Этот параметр определяет будет ли осуществляться редирект с указанного URL.
Значение по умолчанию - `False`. Значение `True` эквивалентно коду '301 Moved Permanently'
Другие возможные значения
Стандартные коды для редиректа:

    '301' : '301 Moved Permanently',
    '302' : '302 Found',
    '303' : '303 See Other',
    '305' : '305 Use Proxy',
    '307' : '307 Temporary Redirect'


Редирект будет произведен на
постоянный URL, указанный для этой же функции-обработчика (URL для которого не задан параметр `redirect`).
Хорошим тоном является наличие у страницы только одного постоянного URL.
Возможные значения 


`**headers`
host, port - если указаны эти параметры, то обработчик будет обрабатывать только запросы на
указанный хост и/или порт.
Если не указаны, обработчик не обращает внимания на эти параметры
host может содержать и port - localhost:8080
redirect - см ниже
headers - можно указать заголовки, которые будут установлены при пересылке страницы пользователю


### Заголовки генерируемой страницы ### 

@http("test", foo_bar="baz")
def myfunction():
    return "hello"

результатом будет страница, в которой будет установлен заголовок Foo-Bar: baz

200 OK
Content-Type: text/plain
Foo-Bar: baz

Можно указать тип и кодировку
@http(type="text/foobar", charset="koi8-r")
def test():
    ...
 
Результатом будет страница, в которой установлен заголовок
Content-Type: text/foobar; charset=koi8-r

### Обработчики для конкретных HTTP методов ###

Обычная запись
@http -
При этом обрабатываются только методы
HEAD, GET, POST
Но не будет обработаны другие методы (такие как PUT, DELETE, etc)
Если наряду с общим обработчиком указан и специфический, например
@http.GET
То Пони перенаправит GET запрос обработчику @http.GET
а POST и HEAD общему.


### Несколько похожих обработчиков ###

@http("/test/$x/abcd")
def test1(x)
 
@http("/test/$a/$b")
def test2(a, b)

/test/333/abcd - first one
/test/333/abce - second one

### Переменное число аргументов ###

@http("/test/$x/$y/$*")
def myfunction(x, y, *args)
/test/ab/cd/ef/gh -> $x=ab, $y=ef, args = ("ef", "gh")
 

### Числовой тип парамера для переменной в URL ###

@http("/test/$x/$y")
def test(x=int, y)

test/100/200 -> x=100, y='200'
/test/abc/def -> Not found

    
URL запрос обычно состоит из протокола, имени домена, порта, пути и параметров:

    http://host.domain:8080/path/to/page?param1=value1&param2=value2
 протокол| имя домена |порт| путь       |  параметры


@http("") и @http("/") в той видимо редкой ситуации, когда корень программа обрабатывает не весь сайт,
а его подраздел (то есть когда SCRIPT_NAME не пустой), в этом случае может быть разница, добавляется слэш в
конце адреса главной страницы или нет

