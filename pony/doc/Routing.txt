URL Роутинг
===========

Назначение веб приложения - генерировать страницы, которые пользователь открывает в браузере.
Динамический веб-сайт - это набор функций-обработчиков, которые вызываются в ответ
на набранные пользователем URL. В этой главе мы рассмотрим как выполняется роутинг.  
По сути, роутинг это сопоставление URL вызову конкретной функции-обработчика.
В этой главе мы рассмотрим и обратную задачу -
генерацию URL для конкретной функции-обработчика.




Сопоставление URL вызову конкретной функции-обработчика
---------------------------------------------------------
Основное назначение роутинга - связать набранный пользователем URL с
функцией-обработчиком на сервере.
Многие фреймворки используют регулярные выражения, чтобы сопоставить функцию для URL.
Регулярные выражения, безусловно, очень мощный инструмент, но вместе с этим часто неудобный в
использовании для большинства пользователей.
Пони предлагает мощный, гибкий, и в то же время простой способ для решения этой
задачи, с которым мы познакомимся в этой главе.




### Связывание URL с функцией-обработчиком ###
Процесс обработки запроса в Пони выглядит следующим образом:
    
  1.  Пользователь набирает URL в браузере.
  2.  HTTP запрос передается браузером веб-серверу.  
  3.  Веб-сервер передает запрос Пони.  
  4.  Пони анализирует запрос, находит соответствующий обработчик,
выделяет параметры из URL запроса и производит вызов функции-обработчика с этими параметрами.
  5.  Функция-обработчик генерирует страницу, которая передается веб-серверу, а затем браузеру пользователя.

Давайте посмотрим как связать URL с функцией-обработчиком. Вот пример законченной программы,
которая генерирует страницу с помощью Пони.

    from pony.main import *     (1)

    @http                       (2)
    def hello():                (3)
        return "Hello world!"   (4) 

    http.start()                (5) 

(1) В первой строчке мы импортируем все самое необходимое для Пони. После того как выполнен
import, мы можем использовать компоненты Пони в нашем коде.  
(2) Здесь функция hello предваряется декоратором @http.  
Тем самым мы сообщаем Пони, что эта функция будет обработчиком для URL и доступна для пользователей веб-сайта.  
(3) Объявление функции hello.  
(4) Возвращаемым значением будет строка "Hello world!".  
(5) Запускаем веб-сервер. По умолчанию веб-сервер обслуживает порт 8080. 
Как и все примеры, мы можем запустить этот пример из интерактивного режима и
посмотреть что получилось.  

После того как мы запустили приведенный выше код в интерактивном режиме или в виде отдельного файла,
мы можем посмотреть на сгенерированую страницу в браузере. Давайте разберемся, какой URL нужно
набрать, чтобы увидеть результат.
Когда мы указываем декоратор http без параметров, Пони по умолчанию строит URL используя имя самой функции.
В этом примере соответствующий этой функции URL будет '/hello'.
Наберем в браузере http://localhost:8080/hello и увидим наше приветствие:

![routing1](/pony/static/img/doc/routing1.png)  
  
Как вы видите из примера, связать URL с функцией-обработчиком в Пони очень просто.  


В случае, если Пони не находит ни одного соответствия URL с функцией-обработчиком, генерируется страница с HTTP
кодом 404 - Not Found.
В режиме отладки на эту страницу выводится список всех зарегистрированных URL.

![routing2](/pony/static/img/doc/routing2.png)  





### Передача параметров в функцию ###
На практике часто возникает необходимость передать параметры на сервер.
Самый простой способ сделать это в Пони - добавить необходимый параметр в функцию-обработчик:

    @http                                                     
    def hello(name):                              
        return "Hello " + name + "!"              

Здесь мы добавили в функцию параметр `name`, который будет отображаться на генерируемой странице.

URL для этой страницы будет немного отличаться от предыдущего.
У функции hello теперь есть обязательный параметр. Раз этот параметр обязательный,
он должен присутствовать в URL. Поскольку мы не задали шаблон для URL(об этом далее),
Пони ожидает, что параметр будет указан в URL следующим способом:

    http://localhost:8080/hello?name=Pony

Если мы наберем этот URL в браузере, то увидим страницу, сгенерированную Пони:

![routing3](/pony/static/img/doc/routing3.png)  





### Значения по умолчанию ###
Если нам нужно, чтобы у параметра было значение по умолчанию, нужно указать это в объявлении
функции:

    @http                                           
    def hello(name='WORLD'):                 
        return "Hello %s!" % name   
                                  
Теперь, если мы не будем указывать ни одного параметра в URL, мы увидим, что Пони будет использовать
значение по умолчанию:

![routing4](/pony/static/img/doc/routing4.png)

Кроме того, мы также можем указать значение параметра в URL явно:    

![routing5](/pony/static/img/doc/routing5.png)

Если внимательно присмотреться к последнему примеру, можно заметить, что здесь мы выводим
результат другим, более удобным способом:

    return "Hello %s!" % name    

В этом примере `%s` определяет место, куда будет подставлен параметр `name`.





### Произвольные URL для функции-обработчика ###
До текущего момента мы не указывали никаких параметров для декоратора @http.
В таком режиме URL, по которому доступна функция строится по умолчанию.
Для нашего примера это будет

    /hello?name=some_name

Это стандартная запись для передачи параметров методом GET. Если мы хотим, чтобы URL был
более компактным и легко читаемым, нужно указать шаблон URL в декораторе @http.
В шаблоне мы указываем где располагается статическая и переменная часть URL. 
    
    @http('/hello/$name')                                           
    def hello(name):                 
        return "Hello %s!" % name

В шаблоне мы указали, что после символов `hello/` в URL ожидается переменная часть, которая будет
передана в функцию в качестве параметра `name`. Теперь нашей функции соответствует URL вида:

    /hello/Pony

![routing6](/pony/static/img/doc/routing6.png)

Переменная часть, то есть параметр начианается с символа `$` и может состоять из символов,
которые разрешены для использования в идентификаторах в Питоне - буквы, цифры и знак подчеркивания.
Параметр может располагаться в любом месте URL. Например в середине:

    @http('/hello/$name/page.html')
    def hello(name):                 
        return "Hello %s!" % name    

Разделителем между параметрами может быть не только символ '/'. Разделитель может быть практически любым символом
кроме букв, цифр и знака подчеркивания. Например:

    @http('/archive/$year-$month/posts')
    def archive2(year=None, month=None):
    	return "archive2"
    
Для этого примера результат выполнения `url(archive2, '2008', '11')` будет 'archive/2008-11/posts'.
Вы можете попробовать разные варианты разделителей в интерактивном режиме.

Параметров может быть несколько:

    @http("/page/$a/$b/$c")
    def test(a, b, c):                 
        return "Hello, %s %s %s!" % (a, b, c)

Чтобы вывести несколько параметров, мы указали их места в строке с помощью символов `%s`.
Затем указали сами параметры в скобках согласно синтаксису Питона. 

Когда Пони сопоставляет URL с конкретной функцией-обработчиком, она выделяет динамические части из URL и
передает в функцию как параметры. 
Если мы хотим, чтобы параметры передавались обычным способом (после знака `?` в URL), мы можем это указать в шаблоне
таким способом:

    @http("/page?a=$a&b=$b")
    def test(a, b):                 
        return "Hello, %s %s!" % (a, b)

Переменными частями здесь будут `$a` и `$b`. В такой записи параметры указываются рядом с именами самих переменных,
поэтому их порядок в URL не важен. Например оба этих URL будут адресованы той же самой функции:

    /page?a=1&b=2
    /page?b=2&a=1

Случается ситуация, когда URL, который написан в декораторе отличается от того, который набран в
браузере только наличием или отсутствием знака '/' на конце. Для пользователя веб-сайта эта разница
может быть не очевидна, поэтому Пони в такой ситуации попробует помочь пользователю все же увидеть запрашиваемую страницу.
Когда Пони анализирует URL полученный от браузера она сначала попытается найти точное соответствие.
Если точное соответствие есть - вызывается соответствующий обработчик.
Если точное совпадение не найдено, Пони попробует убрать/подставить слэш в конце URL (или перед знаком `?`) и найти
обработчик для такого URL. Если при этом найдено соответствие, Пони автоматически выполняет редирект
по найденному адресу. Таким образом для приведенных ранее примеров URL `/hello/Pony/`
будет автоматически переадресован на `/hello/Pony`, а `/page/?a=1&b=2` будет автоматически переадресован
на `/page?a=1&b=2`.






### Несколько URL для одного обработчика ###
В какой то момент вам может понадобиться изменить структуру адресов веб-сайта.
Используя возможности Пони это можно сделать довольно быстро, но нам нужно помнить, что некоторые пользователи
могли сделать закладки, используя старые адреса. Если просто поменять URL страниц,
закладки, сделанные с использованием старых адресов, перестанут работать. 
Пользователи, которые приходят
на ваш веб-сайт через поисковую машину тоже будут испытывать неудобства - пройдет какое-то время,
пока она перестроит индекс и заменит старые URL на новые.

Используя роутинг в Пони можно очень легко изменять структуру веб-сайта,
не нарушая при этом работы тех пользователей, которые привыкли работать со старой структурой.
Одной и той же функции-обработчику может быть сопоставлено несколько URL:

    @http('/hello?name=$name')
    @http('/hi/$name')                                           
    def hello(name='WORLD'):                 
        return "Hello %s!" % name

При обработке первого указанного URL мы можем использовать либо имя заданное по умолчанию, либо стандартную
передачу параметра в функцию:

![routing7](/pony/static/img/doc/routing7.png)

![routing8](/pony/static/img/doc/routing8.png)

Второй URL связанный с этой функцией отображает ту же самую страницу.

Хорошим тоном считается иметь один постоянный адрес для страницы. Обращения к той же самой странице
по другим URL следует переадресовывать на постоянный адрес. Мы поговорим об этом подробнее далее 
в этой главе, а сейчас просто сделаем переадресацию с одного URL на другой. Для этого добавим
в декоратор первого URL параметр `redirect=True`:

    @http('/hello?name=$name', redirect=True)
    @http('/hi/$name')                                           
    def hello(name='world'):                 
        return "Hello %s!" % name

Теперь, обращаясь к странице по URL `/hello?name=Pony`, мы автоаматически попадем на страницу `/hi/Pony`    

До текущего момента наши страницы генерировалась в виде простого текста.
Тип генерируемой страницы в Пони по умолчанию - `plain/text`.
Чтобы сгенерировать HTML страницу нам нужно просто указать параметр type='text/html' в декораторе:

    @http(type='text/html')
    def hello(name='world'):                 
        return "<html><h1>Hello %s!<h1></html>" % name   

Теперь страница выглядит совсем по другому:
    
![routing9](/pony/static/img/doc/routing9.png)
    
Далее мы рассмотрим более удобные способы генерации HTML страниц.





### Генерация URL для функции-обработчика ###
Ранее мы познакомились с тем, как отображать URL на функцию-обработчик.
Часто при построении динамического веб-сайта возникает обратная задача - отобразить
URL, который соответствует определенной функции-обработчику. 
Допустим у нас есть функция, которая генерирует страницу со списком опубликованных статей
за указанный год и месяц:

    @http('/archive/$year/$month/articles')
    def articles(year, month):
        return 'list of articles'

Задача - добавить в код страницы URL, указывающий на список статей за май 2009 года. Проанализировав шаблон URL мы можем
просто подставить значения в этот шаблон и получить URL '/archive/2009/5/articles'. Теперь мы можем добавить этот URL
в код страницы вручную. Однако, если впоследствии мы изменим шаблон для этой функции, нам нужно будет не забыть поменять
добавленный ранее вручную URL. Это не очень удобно, особенно если таких URL и мест, куда их нужно добавить много.
Для генерации URL в Пони используется функция `url`, которой передается
функция-обработчик и ее параметры.
Для нашего примера использование этой функции будет выглядеть следующим образом:

    url(articles, '2009', '5')

Здесь мы генерируем URL для функции-обработчика `articles`, поэтому указываем ее первым аргументом.
Затем указываются параметры функции `articles`.

Если мы выполним этот код в интерактивном режиме, то тут же увидим результат:    

    >>> from pony.main import *
    >>> @http('/archive/$year/$month/articles')
    ... def articles(year, month):
    ...     return 'list of articles'
    ... 
    >>> url(articles, '2009', '5')
    '/archive/2009/5/articles'

Использование функции `url` для генерации URL позволяет менять структуру адресов веб-сайта,
не изменяя при этом сами функции, которые генерируют страницы. 





### Связывание URL с функцией-обработчиком в отдельном файле ###
В примерах, приведенных в этой главе, мы связываем URL с функцией-обработчиком с помощью декоратора
@http, который располагается непосредственно перед функцией.
Другой вариант связывания, который обычно предлагают другие фреймворки - использовать для связывания
отдельный файл или специальный класс. Каждый подход имеет свои плюсы и минусы.
Пони предоставляет возможность использовать как и рассмотренный ранее подход,
так и связывание отдельно от функций-обработчиков. Выбор остается за пользователем Пони.

Использование декоратора удобно для работы в интерактивном режиме, а также когда проект состоит из небольшого
числа функций. Если в проекте много файлов и функций-обработчиков, тогда может быть удобно связать URL
с функциями-обработчиками в отдельном файле. Давайте рассмотрим этот подход на примере.

Допустим, у нас есть проект `myproject`, который состоит из двух модулей - `module1` и `module2`.
В отдельном файле нам нужно сначала импортировать компоненты Pony, среди которых содержится нужная нам функция`http`.
Затем импортировать функции-обработчики. В приведенном ниже примере мы делаем это двумя разными способами.
Далее в файле производится связывание URL с функциями-обработчиками: сначала указывается сама функция `http`, затем в
скобках записывается URL, затем в скобках указывается функция-обработчик.
Если для функции мы хотим построить URL по умолчанию, тогда URL не указывается - сразу после `http` идет функция-обработчик.

    from pony.main import *                     (1)
    from myproject.module1 import page1, page2  (2)
    from myproject import module2               (3)

    http(page1)                                 (4)
    http('/path')(page2)                        (5)
    http('/path/$x/$y')(module2.page3)          (6)

(1) Импортируем компоненты Pony стандартным способом.  
(2) Импортируем из модуля module1 только две функции-обработчика: page1 и page2.  
(3) Импортируем модуль module2.  
(4) Связываем функцию page1 с URL. Так как URL здесь не указан, он будет построен автоматически исходя из объявления функции page1.  
(5) Связываем функцию page2 с URL 'path'.  
(6) Связываем функцию page3 из модуля module2 с URL '/path/$x/$y'.  





### Переменное число аргументов ###
Если число параметров в URL заранее неизвестно, удобно воспользоваться возможностью передавать в функцию
произвольное число параметров:

    @http("/test/$x/$y/$*")
    def myfunction(x, y, *args):
        return 'args=%s' % str(args)

----------- переписать, учесть, что после может еще идти ? и после него аргументы ------
Запись `$*` сообщает Пони, что в этом месте в URL могут быть любые символы. Все они будут интерпретированы
как параметр `*args`. Указатель на переменное число параметров `$*` должен идти в шаблоне URL после всех переменных с разделителями.
После указателя на переменное число параметров может идти
-----------------------------------------
Если мы передадим такой URL на сервер `/test/ab/cd/ef/gh`, то в результате переменным будут присвоены
следующие значения: x=ab, y=ef, args = ('ef', 'gh'). Здесь первая группа параметров `ab/cd` распределяется
между переменными `x` и `y` согласно заданному шаблону. Для параметра `*args` остается часть URL `ef/gh`, которая
представляется в виде кортежа ('ef', 'gh'). Для частей последнего аргумента разделителем всегда является символ '/'.






### Редирект ###
Рассмотренная ранее возможность использования нескольких URL для одной и той же страницы
может быть удобна, если возникает необходимость введения новой структуры адресов для веб сайта.
Но вместе с удобством появляется неоднозначность. Пользователи не могут определить по внешнему виду какой адрес
старый, а какой новый. 
Поисковые машины присваивают бОльший рейтинг страницам с бОльшим числом линков на них. Если у одной и той же страницы
несколько адресов, то разные люди будут делать ссылки на разные адреса и это понизит эффективность веб-сайта.

Хорошей практикой считается иметь один постоянный URL для страницы. Если по какой то причине нужно
сопоставить странице альтернативный URL, нужно обеспечить редирект с альтернативных адресов на
постоянный URL. Редирект - это автоматическая переадресация браузера на другой URL.
Для того, чтобы обеспечить редирект на новый адрес нужно указать `redirect=True` в декораторе со старым URL.
Для предыдущего примера это будет выглядеть так:

    @http('/archive/posts.php?year=$year&month=$month', redirect=True)
    @http('/archive/$year/$month/posts')    
    def archive2(year=None, month=None):
    	return 'test'

Редирект может быть нескольких типов, самые часто используемые из которых - постоянный и временный.
По умолчанию, если указать параметр `redirect=True`, Пони делает постоянный редирект
с кодом '301 Moved Permanently'.
Если поисковая машина натыкается на постоянный редирект, то отныне она будет обращаться сразу по новому адресу.
Временный редирект обозначается кодом '307 Temporary Redirect'.
Если редирект временный, то поисковая машина не должна заменять старый адрес на новый.
Чтобы сделать временный редирект, или редирект какого то другого типа, нужно указать код редиректа
в качестве параметра:

    @http('/archive/$year-$month/posts', redirect='307 Temporary Redirect')

Другие возможные значения параметра `redirect` приведены __здесь___ (ссылка на routing-reference).









### Обработчики для конкретных HTTP методов ###
HTTP запрос может передаваться на сервер с помощью различных HTTP методов.
Самые распространенные из них - GET, POST, HEAD.
Когда мы объявляем функцию-обработчик с помощью декоратора @http,
то по умолчанию функция обрабатывает только эти три метода. Если от сервера придет запрос
с помощью другого метода, например PUT или DELETE, такой запрос обработан не будет 
и Пони сгенерирует страницу '404 Not Found'.
Если вы хотите создать функцию-обработчик, которая должна обрабатывать другие HTTP методы,
нужно указать их явно. В примере приведенном ниже функция `test_delete` обрабатывает только запросы
HTTP методом DELETE: 

    @http.DELETE('/test')
    def test_delete():
        return 'method DELETE'

В этом примере

    @http('/test')
    def test():
        return 'methods GET, POST, HEAD'

Для всех трех методов - GET, POST, HEAD, будет вызвана функция `test_all_three`.
Если мы хотим, чтобы при обращении к одному и тому же URL для метода POST вызывалась одна функция,
а для GET и HEAD другая, нужно написать следующий код:

    @http('/test')
    def test():
        return 'method GET and HEAD'

    @http.POST('/test')
    def test_post():
        return 'method POST only'






--------------------- еще не дописано ----------------------

### Автоматическое преобразование типа для переменных в URL ###
По умолчанию, все переменные, которые извлекаются из URL имееют строковый тип (str).
Пони позволяет указать тип ожидаемых переменных

Иногда бывает удобно указать, что в функции ожидается числовое значение.
При сопоставлении URL с функцией Пони преобразует отмеченные переменные к числовому типу.
Если преобразование невозможно, Пони считает, что эта функция не совпадает с URL.
Например:

    @http("test/$x/$y")
    def test(x=int, y):
        return "test"

Обращение к URL '/test/100/200' будет преобразована к вызову функции `test` с параметрами x=100, y='200'.
Обращение к URL '/test/abc/def' в результате приведет к отображению страницы '404 Not Found'




### Несколько похожих обработчиков ###

@http("/test/$x/abcd")
def test1(x)
 
@http("/test/$a/$b")
def test2(a, b)

/test/333/abcd - first one
/test/333/abce - second one

